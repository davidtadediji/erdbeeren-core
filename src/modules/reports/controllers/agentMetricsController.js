// src\modules\reports\controllers\agentMetricsController.js
// Import logger and initialize PrismaClient
import { PrismaClient } from "@prisma/client";
import logger from "../../../../logger.js";

const prisma = new PrismaClient();

// Function to get all agent IDs
export async function getAllAgentIds(req, res, next) {
  logger.info("Get all agent ids triggered");
  try {
    // fetch all users with role "agent" and selecting only their IDs
    const agents = await prisma.user.findMany({
      where: { role: "agent" },
      select: {
        id: true,
      },
    });

    // extract the ID for each agents
    const agentIds = agents.map((agent) => agent.id);

    // send the agent IDs as a response back to the report screen for the monitor/admin
    res.json({
      agentIds,
    });
  } catch (error) {
    next(error);
  } finally {
    await prisma.$disconnect();
  }
}

/* Function to get average response time for a specific human agent, 
this metric is precalcuated by the analytics engine */
export async function getAvgAgentResponseTime(req, res, next) {
  try {
    const agentId = req.params.agentId;

    // fetch the agent by the selected agent ID
    const agent = await prisma.user.findUnique({
      where: { id: parseInt(agentId) },
    });

    // extract the average response time generated by the analytics engine
    const avgAgentResponseTime = agent.averageResponseTime;

    // send the average response time as a report metric to the monitor/admin
    res.json({
      agent: agentId,
      metric: "Agent Response Time Metrics",
      avgAgentResponseTime,
    });
  } catch (error) {
    next(error);
  } finally {
    await prisma.$disconnect();
  }
}

// Function to get email address for a specific human agent
export async function getEmailAddress(req, res, next) {
  try {
    const agentId = req.params.agentId;

    // fetch the agent by ID
    const agent = await prisma.user.findUnique({
      where: { id: parseInt(agentId) },
    });

    // extract their email address
    const emailAddress = agent.email;

    // send the email address as a response
    res.json({
      agent: agentId,
      metric: "Agent Email Address",
      emailAddress,
    });
  } catch (error) {
    next(error);
  } finally {
    await prisma.$disconnect();
  }
}

// Function to get average handling time for a specific human agent, this metric is calculated on demand.
export async function getAverageHandlingTime(req, res, next) {
  try {
    const agentId = req.params.agentId;

    // fetch all closed tickets for the agent using the selected agent ID
    const tickets = await prisma.ticket.findMany({
      where: {
        userId: parseInt(agentId),
        status: "closed",
      },
      select: {
        createdAt: true,
        closedAt: true,
      },
    });

    // If there are no tickets, respond with 0 average handling time
    const numberOfTickets = tickets.length;
    if (!numberOfTickets) {
      res.json({
        agent: agentId,
        metric: "Agent Average Handling Time",
        averageHandlingTime: 0,
      });
    }

    /* calculate the total handling time of human agents using the reduce function 
    which accumulates the values of an array based on a given condition*/
    const totalHandlingTime = tickets.reduce((acc, ticket) => {
      if (ticket.createdAt && ticket.closedAt) {
        const difference =
          (new Date(ticket.closedAt) - new Date(ticket.createdAt)) /
          (1000 * 60); // get time difference in minutes
        return acc + difference;
      } else {
        return acc;
      }
    }, 0);

    // Calculate the average handling time and convert to 2 decimal places
    const averageHandlingTime = (totalHandlingTime / numberOfTickets).toFixed(
      2
    );

    // Send the average handling time as a report metric back to the monitor/admin report dashboard as well.
    res.json({
      agent: agentId,
      metric: "Agent Average Handling Time",
      averageHandlingTime,
    });
  } catch (error) {
    next(error);
  } finally {
    await prisma.$disconnect();
  }
}

/* Function to get average customer satisfaction score for a specific agent, the customer satisfaction is extracted
on from messages, but the aggregate and average is calculated when requested, rather than precalculation by the engine*/
export async function getAverageCustomerSatisfactionScore(req, res, next) {
  try {
    const agentId = req.params.agentId;

    // calculate average customer satisfaction score for closed tickets of the agent
    const averageSatisfactionScore = await prisma.ticket.aggregate({
      where: {
        userId: parseInt(agentId),
        status: "closed",
      },
      _avg: {
        customerSatisfactionScore: true,
      },
    });

    // send the average satisfaction score as a response
    res.json({
      metric: "Average Customer Satisfaction Score",
      data: averageSatisfactionScore,
    });
  } catch (error) {
    next(error);
  } finally {
    await prisma.$disconnect();
  }
}

// Function to get ticket volume for a specific agent, engine precalculation was also not appropriate here.
export async function getTicketVolume(req, res, next) {
  try {
    const agentId = req.params.agentId;

    // fetch ticket volume data using raw SQL query, prisma ORM could not be used due to query complexity
    const data = await prisma.$queryRaw`
    SELECT 
      DATE("createdAt") AS date,
      COUNT(*) AS total_tickets,
      SUM(CASE WHEN status = 'closed' THEN 1 ELSE 0 END) AS closed_tickets
    FROM 
      public."Ticket"
    WHERE 
      "userId" = ${parseInt(agentId)}
    GROUP BY 
      DATE("createdAt")
    ORDER BY 
      DATE("createdAt");
  `;
    /*
     * The query above retrieves the ticket statistics for a specific agent.
     * It selects the creation date, the total number of tickets, and the total number of closed tickets.
     * The results are grouped by the ticket creation date and ordered by the creation date.
     * The agent is identified by a given user ID.
     */

    // format the fetched data to be compatible with the expected input for the chart on the frontend
    const formattedData = data.map((entry) => ({
      date: entry.date.toISOString().split("T")[0],
      total_tickets: parseInt(entry.total_tickets, 10),
      closed_tickets: parseInt(entry.closed_tickets, 10) || 0,
    }));

    // send the ticket volume data to the admin/monitor performance report screen
    res.json({
      agent: agentId,
      metric: "Agent Ticket Volume",
      ticketVolume: formattedData,
    });
  } catch (error) {
    logger.error("Error fetching ticket volume data:", error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}
